using ShaderInputsParserApp.Source.Types;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace ShaderInputsParserApp.Source
{
    class HeaderWriter
    {
        private Dictionary<string, string> m_typesToKiotoDefaults = new Dictionary<string, string>()
        {
            { "float", "0" },
            { "float2", "Vector2()" },
            { "float3", "Vector3()" },
            { "float4", "Vector4()" },
            { "float3x3", "Matrix3()" },
            { "float4x4", "Matrix4()" }
        };
        private Dictionary<string, string> m_shaderStagesToKioto = new Dictionary<string, string>()
        {
            { "VS", "ShaderProgramType::Vertex" },
            { "PS", "ShaderProgramType::Fragment" },
            { "CS", "ShaderProgramType::Compute" }
        };
        private Dictionary<string, string> m_typeToKiotoFormat = new Dictionary<string, string>()
        {
            { "float", "eDataFormat::R8" },
            { "float2", "eDataFormat::R8_G8" },
            { "float3", "eDataFormat::R8_G8_B8" },
            { "float4", "eDataFormat::R8_G8_B8_A8" },
        };
        private Dictionary<string, string> m_semanticToKiotoSemantic = new Dictionary<string, string>()
        {
            { "POSITION", "eVertexSemantic::Position" },
            { "NORMAL", "eVertexSemantic::Normal" },
            { "TEXCOORD", "eVertexSemantic::Texcoord" },
            { "COLOR", "eVertexSemantic::Color" }
        };
        public HeaderWriter(string filename)
        {
            Filename = filename;
        }

        public void WriteHLSLHeaders(ShaderOutputContext ctx)
        {
            Antlr4.StringTemplate.TemplateGroup group = new Antlr4.StringTemplate.TemplateGroupFile(Environment.CurrentDirectory + "/Templates/hlslTemplate.stg");
            StringBuilder result = new StringBuilder();
            result.Append("//////////////////////////////////////////////// \n");
            result.Append("////////// AUTOGENERATED FILE, DO NOT EDIT !//// \n");
            result.Append("//////////////////////////////////////////////// \n");

            List<string> includes = ctx.Includes;
            foreach (var include in includes)
            {
                Antlr4.StringTemplate.Template inclTemplate = group.GetInstanceOf("include");
                inclTemplate.Add("path", include);
                result.Append(inclTemplate.Render() + '\n');
            }
            result.Append('\n');
            result.Append('\n');

            result.Append("///////////////// STRUCTURES /////////////////// ");
            result.Append('\n');

            List<Structure> ss = ctx.Structures;
            foreach (var s in ss)
            {
                StringBuilder members = new StringBuilder();
                foreach (var member in s.Members)
                {
                    Antlr4.StringTemplate.Template varTemplate = group.GetInstanceOf("var");
                    varTemplate.Add("type", Variable.ConvertHlslType(member.Type));
                    varTemplate.Add("name", member.Name);
                    members.Append(varTemplate.Render() + '\n');
                }
                Antlr4.StringTemplate.Template structTemplate = group.GetInstanceOf("struct");
                structTemplate.Add("name", s.Name);
                structTemplate.Add("members", members);
                result.Append(structTemplate.Render() + '\n' + '\n');
            }

            result.Append('\n');
            result.Append('\n');

            result.Append("///////////////// CONSTANT BUFFERS /////////////////// ");
            result.Append('\n');

            List<ConstantBuffer> constantBuffers = ctx.ConstantBuffers;

            foreach (var cbuffer in constantBuffers)
            {
                StringBuilder members = new StringBuilder();
                foreach (var member in cbuffer.Members)
                {
                    Antlr4.StringTemplate.Template varTemplate = group.GetInstanceOf("var");
                    varTemplate.Add("type", Variable.ConvertHlslType(member.Type));
                    varTemplate.Add("name", member.Name);
                    members.Append(varTemplate.Render() + '\n');
                }
                Antlr4.StringTemplate.Template cbufferTemplate = group.GetInstanceOf("cbuffer");
                cbufferTemplate.Add("name", cbuffer.Name);
                cbufferTemplate.Add("members", members);
                cbufferTemplate.Add("reg", cbuffer.Bindpoint.Reg);
                cbufferTemplate.Add("space", cbuffer.Bindpoint.Space);
                result.Append(cbufferTemplate.Render() + '\n' + '\n');
            }

            result.Append('\n');
            result.Append('\n');

            result.Append("///////////////// TEXTURES /////////////////// ");
            result.Append('\n');

            List<Texture> textures = ctx.Textures;

            foreach (var t in textures)
            {
                Antlr4.StringTemplate.Template texTemplate = group.GetInstanceOf("tex2d");
                texTemplate.Add("name", t.Name);
                texTemplate.Add("reg", t.Bindpoint.Reg);
                texTemplate.Add("space", t.Bindpoint.Space);
                result.Append(texTemplate.Render() + '\n');
            }

            result.Append('\n');
            result.Append('\n');

            result.Append("///////////////// SAMPLERS /////////////////// ");
            result.Append('\n');

            List<Sampler> samplers = ctx.Samplers;
            foreach (var s in samplers)
            {
                Antlr4.StringTemplate.Template smplrTemplate = group.GetInstanceOf("sampler");
                smplrTemplate.Add("name", s.Name);
                smplrTemplate.Add("reg", s.Bindpoint.Reg);
                smplrTemplate.Add("space", s.Bindpoint.Space);
                result.Append(smplrTemplate.Render() + '\n');
            }

            string outDirHlsl = Program.OutputDir + "/hlsl/";
            string filenameOut = outDirHlsl + Filename + ".hlsl";
            System.IO.File.WriteAllText(filenameOut, result.ToString());
        }

        public void WriteCPPHeaders(ShaderOutputContext ctx)
        {
            Antlr4.StringTemplate.TemplateGroup group = new Antlr4.StringTemplate.TemplateGroupFile(Environment.CurrentDirectory + "/Templates/cppTemplate.stg");

            StringBuilder cbsResult = new StringBuilder();
            List<ConstantBuffer> cbs = ctx.ConstantBuffers;
            foreach (var cb in cbs)
            {
                StringBuilder membersResult = new StringBuilder();
                foreach (var m in cb.Members)
                {
                    Antlr4.StringTemplate.Template cbmTemplate = group.GetInstanceOf("cbmember");
                    cbmTemplate.Add("cbname", cb.Name);
                    cbmTemplate.Add("memberName", m.Name);
                    cbmTemplate.Add("initVal", m_typesToKiotoDefaults[m.Type]);
                    membersResult.Append(cbmTemplate.Render() + "\n");
                }
                Antlr4.StringTemplate.Template cbTemplate = group.GetInstanceOf("cbuffer");
                cbTemplate.Add("cbname", cb.Name);
                cbTemplate.Add("reg", cb.Bindpoint.Reg.ToString());
                cbTemplate.Add("space", cb.Bindpoint.Space.ToString());
                cbTemplate.Add("addParams", membersResult.ToString());
                cbsResult.Append(cbTemplate.Render() + '\n');
            }

            List<Texture> texs = ctx.Textures;

            StringBuilder texturesRes = new StringBuilder();
            foreach (var t in texs)
            {
                Antlr4.StringTemplate.Template tTemplate = group.GetInstanceOf("texture");
                tTemplate.Add("name", t.Name);
                tTemplate.Add("reg", t.Bindpoint.Reg);
                texturesRes.Append(tTemplate.Render() + '\n');
            }
            Antlr4.StringTemplate.Template tSetTemplate = group.GetInstanceOf("texSet");
            tSetTemplate.Add("addParams", texturesRes.ToString());
            string texSetsResult = tSetTemplate.Render();

            StringBuilder shadersBindingRes = new StringBuilder();
            List<ShaderBinding> shaderBinds = ctx.ShaderBinding.Bindings;
            for (int i = 0; i < shaderBinds.Count; ++i)
            {
                shadersBindingRes.Append("uint8(" + m_shaderStagesToKioto[shaderBinds[i].ShaderType] + ")");
                if (i != (shaderBinds.Count - 1))
                    shadersBindingRes.Append(" | ");
            }

            List<VertexLayoutMember> vlayoutMembers = ctx.VertLayout.Members;
            StringBuilder vertLayoutParseRes = new StringBuilder();
            foreach (var vlm in vlayoutMembers)
            {
                Antlr4.StringTemplate.Template vlmTemplate = group.GetInstanceOf("vlayoutmember");
                vlmTemplate.Add("semantic", m_semanticToKiotoSemantic[vlm.Semantic]);
                vlmTemplate.Add("index", vlm.SemanticIndex);
                vlmTemplate.Add("format", m_typeToKiotoFormat[vlm.Type]);
                vertLayoutParseRes.Append(vlmTemplate.Render() + '\n');
            }

            Antlr4.StringTemplate.Template headerTemplate = group.GetInstanceOf("header");
            headerTemplate.Add("name", "Diffuse");
            headerTemplate.Add("cbuffers", cbsResult.ToString());
            headerTemplate.Add("texSets", texSetsResult);
            headerTemplate.Add("shaderProgs", shadersBindingRes.ToString());
            headerTemplate.Add("vertexLayout", vertLayoutParseRes.ToString());

            string outDirHlsl = Program.OutputDir + "/cpp/";
            string filenameOut = outDirHlsl + Filename + ".h";
            System.IO.File.WriteAllText(filenameOut, headerTemplate.Render());
        }

        string Filename { get; set; }
    }
}
